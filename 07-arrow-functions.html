<p><i><a href="https://hacks.mozilla.org/category/es6-in-depth/" target="_blank">ES6 In Depth</a> is a series on new features being added to the JavaScript programming language in the 6th Edition of the ECMAScript standard, ES6 for short.</i></p>

<p>Arrows have been part of JavaScript from the very beginning. The first JavaScript tutorials advised wrapping inline scripts in HTML comments. This would prevent browsers that <em>didn't</em> support JS from erroneously displaying your JS code as text. You would write something like this:</p>

<pre>
&lt;script language="javascript"&gt;
&lt;!--
  document.bgColor = "brown";  // red
// --&gt;
&lt;/script&gt;
</pre>

<p>Old browsers would see two unsupported tags and a comment; only new browsers would see JS code.</p>

<p>To support this odd hack, the JavaScript engine in your browser treats the characters <code>&lt;!--</code> as the start of a one-line comment. No joke. This has really been part of the language all along, and it works to this day, not just at the top of an inline <code>&lt;script&gt;</code> but everywhere in JS code. It even works in Node.</p>

<p>As it happens, <a href="http://people.mozilla.org/~jorendorff/es6-draft.html#sec-html-like-comments">this style of comment is standardized for the first time in ES6.</a> But this isn't the arrow we're here to talk about.</p>

<p>The arrow sequence <code>--&gt;</code> also denotes a one-line comment. Weirdly, while in HTML characters <em>before</em> the <code>--&gt;</code> are part of the comment, in JS the rest of the line <em>after</em> the <code>--&gt;</code> is a comment. But this arrow only indicates a comment when it appears at the start of a line. That's because <code>--&gt;</code> is also an operator in JS, the "goes to" operator!</p>

<pre>
function countdown(n) {
  while (n --&gt; 0)  // "n goes to zero"
    alert(n);
  blastoff();
}
</pre>

<p><a href="http://codepen.io/anon/pen/oXZaBY?editors=001">This code really works.</a> The loop runs until <var>n</var> gets to 0. This too is <em>not</em> a new feature in ES6, but a combination of familiar features, with a little misdirection thrown in. Can you figure out what's going on here? As usual, the answer to the puzzle can be found <a href="http://stackoverflow.com/questions/1642028/what-is-the-name-of-the-operator">on Stack Overflow</a>.</p>

<p>Of course there is also the less-than-or-equal-to operator, <code>&lt;=</code>. Perhaps you can find more arrows in JS, Hidden Pictures style, but let's stop here and observe that <em>there is an arrow missing</em>.</p>

<table border="1">
  <tr>
    <td><code>&lt;!--</code></td>
    <td>single-line comment</td>
  </tr>
  <tr>
    <td><code>--&gt;</code></td>
    <td>"goes to" operator</td>
  </tr>
  <tr>
    <td><code>&lt;=</code></td>
    <td>less than or equal to</td>
  </tr>
  <tr>
    <td><code>=&gt;</code></td>
    <td>???</td>
  </tr>
</table>

<p>What happened to <code>=&gt;</code>? Today, we find out.</p>

<p>First, let's talk a bit about functions.</p>


<h3>Function expressions are everywhere</h3>

<p>A fun feature of JavaScript is that any time you need a function, you can just type that function right in the middle of running code.</p>

<p>For example, suppose you are trying to tell the browser what to do when the user clicks on a particular button. You start typing:</p>

<pre>
$("#confetti-btn").click(
</pre>

<p>jQuery's <code>.click()</code> method takes one argument: a function. No problem. You can just type in a function right here:</p>

<pre>
$("#confetti-btn").click(function (event) {
  playTrumpet();
  fireConfettiCannon();
});
</pre>

<p>Writing code like this comes quite naturally to us now. So it's strange to recall that before JavaScript popularized this kind of programming, many languages <em>did not have this feature</em>. Of course Lisp had function expressions, also called <dfn>lambda functions</dfn>, in 1958. But C++, Python, C#, and Java all existed for years without them.</p>

<p>Not anymore. All four have lambdas now. Newer languages universally have lambdas built in. We have JavaScript to thank for this—and early JavaScript programmers who fearlessly built libraries that depended heavily on lambdas, leading to widespread adoption of the feature.</p>

<p>It is just slightly sad, then, that of all the languages I've mentioned, JavaScript's syntax for lambdas has turned out to be the wordiest.</p>

<pre>
// A very simple function in six languages.
function (a) { return a &gt; 0; } // JS
[](int a) { return a &gt; 0; }  // C++
(lambda (a) (&gt; a 0))  ;; Lisp
lambda a: a &gt; 0  # Python
a =&gt; a &gt; 0  // C#
a -&gt; a &gt; 0  // Java
</pre>


<h3>A new arrow in your quiver</h3>

<p>ES6 introduces a new syntax for writing functions.</p>

<pre>
// ES5
var selected = allJobs.filter(<strong>function (job) {
  return job.isSelected();
}</strong>);

// ES6
var selected = allJobs.filter(<strong>job => job.isSelected()</strong>);
</pre>

<p>When you just need a simple function with one argument, the new arrow function syntax is simply <code><i>Identifier</i> =&gt; <i>Expression</i></code>. You get to skip typing <code>function</code> and <code>return</code>, as well as some parentheses, braces, and a semicolon.</p>

<p>(I am personally very grateful for this feature. Not having to type <code>function</code> is important to me, because I inevitably type <code>functoin</code> instead and have to go back and correct it.)</p>

<p>To write a function that has multiple arguments (or uses <a href="https://hacks.mozilla.org/2015/05/es6-in-depth-rest-parameters-and-defaults/">rest parameters or defaults</a>) you'll need to add parentheses around the argument list.</p>

<pre>
// ES5
var total = values.reduce(<strong>function (a, b) {
  return a + b;
}</strong>, 0);

// ES6
var total = values.reduce(<strong>(a, b) => a + b</strong>, 0);
</pre>

<p>I think it looks pretty nice.</p>

<p>Arrow functions work just as beautifully with functional tools provided by libraries, like <a href="underscorejs.org">Underscore.js</a> and <a href="https://facebook.github.io/immutable-js/">Immutable</a>. In fact, the examples in <a href="https://facebook.github.io/immutable-js/docs/#/">Immutable's documentation</a> are all written in ES6, so many of them already use arrow functions.</p>

<p>What about not-so-functional settings? Arrow functions can contain a block of statements instead of just an expression. Recall our earlier example:</p>

<pre>
// ES5
$("#confetti-btn").click(<strong>function (event)</strong> {
  playTrumpet();
  fireConfettiCannon();
});
</pre>

<p>Here's how it will look in ES6:</p>

<pre>
// ES6
$("#confetti-btn").click(<strong>event =&gt;</strong> {
  playTrumpet();
  fireConfettiCannon();
});
</pre>

<p>A minor improvement. The effect on code using Promises can be more dramatic, as the <code>}).then(function (result) {</code>s occasionally pile up.</p>

<p>Note that an arrow function with a block body does not automatically return a value. Use a <code>return statement for that.</p>

<p>There is one caveat when using arrow functions to create plain objects. Always wrap the object in parentheses:</p>

<pre>
// create a new empty object for each puppy to play with
var chewToys = puppies.map(puppy => {});   // BUG!
var chewToys = puppies.map(puppy => ({})); // ok
</pre>

<p>Unfortunately, an empty object <code>{}</code> and an empty block <code>{}</code> look exactly the same. The rule in ES6 is that <code>{</code> immediately following an arrow is always treated as the start of a block, never the start of an object. The code <code>puppy => {}</code> is therefore silently interpreted as an arrow function that does nothing and returns <code>undefined</code>.</p>

<p>Even more confusing, an object literal like <code>{key: value}</code> looks exactly like a block containing a labeled statement—at least, that's how it looks to your JavaScript engine. Fortunately <code>{</code> is the only ambiguous character, so wrapping object literals in parentheses is the only trick you need to remember.</p>


<h3>What's <code>this</code>?</h3>

<p>There is one subtle difference in behavior between ordinary <code>function</code> functions and arrow functions. <strong>Arrow functions do not have their own <code>this</code> value.</strong> The value of <code>this</code> inside an arrow function is always inherited from the enclosing scope.</p>

<p>Before we try and figure out what that means in practice, let's back up a bit.</p>

<p>How does <code>this</code> work in JavaScript? Where does its value come from? <a href="http://stackoverflow.com/questions/3127429/how-does-the-this-keyword-work">There's no short answer.</a> If it seems simple in your head, it's because you've been dealing with it for a long time!</p>

<p>One reason this question comes up so often is that <code>function</code> functions receive a <code>this</code> value automatically, whether they want one or not. Have you ever written this hack?</p>

<pre>
{
  ...
  addAll: function addAll(pieces) {
    var self = this;
    _.each(pieces, function (piece) {
      self.add(piece);
    });
  },
  ...
}
</pre>

<p>Here, what you'd <em>like</em> to write in the inner function is just <code>this.add(piece)</code>. Unfortunately, the inner function doesn't inherit the outer function's <code>this</code> value. Inside the inner function, <code>this</code> will be <code>window</code> or <code>undefined</code>. The temporary variable <code>self</code> serves to smuggle the outer value of <code>this</code> into the inner function. (Another way is to use <code>.bind(this)</code> on the inner function. Neither way is particularly pretty.) </p>

<p>In ES6, <code>this</code> hacks mostly go away if you follow these rules:</p>

<ul>
  <li><p>Use non-arrow functions for methods that will be called using the <code>object.method()</code> syntax. Those are the functions that will receive a <em>meaningful</em> <code>this</code> value from their caller.</p></li>

  <li><p>Use arrow functions for everything else.</p></li>
</ul>

<pre>
// ES6
{
  ...
  addAll: function addAll(pieces) {
    _.each(pieces, piece => this.add(piece));
  },
  ...
}
</pre>

<p>In the ES6 version, note that the <code>addAll</code> method receives <code>this</code> from its caller. The inner function is an arrow function, so it inherits <code>this</code> from the enclosing scope.</p>

<p>As a bonus, ES6 methods provide a shorter way to write methods in object literals! So the code above can be simplified further:</p>

<pre>
// ES6 with method syntax
{
  ...
  addAll(pieces) {
    _.each(pieces, piece => this.add(piece));
  },
  ...
}
</pre>

<p>Between method syntax and arrows, you might never type <code>functoin</code> again!</p>

<p>There's one more minor difference between arrow and non-arrow functions: arrow functions don't get their own <code>arguments</code> object, either. Of course, in ES6, you'd probably rather use a rest parameter or default value anyway.</p>


<h3>When can I use arrows?</h3>

<p>...</p>

http://piotrwalat.net/arrow-function-expressions-in-typescript/

<p>Next time, we'll discuss one of the stranger features in ES6. So please join us next week for a look at ES6 symbols in depth.</p>
